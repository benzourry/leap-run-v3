// Copyright (C) 2018 Razif Baital
// 
// This file is part of LEAP.
// 
// LEAP is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
// 
// LEAP is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with LEAP.  If not, see <http://www.gnu.org/licenses/>.

import { Component, OnInit, AfterViewChecked, ChangeDetectorRef, OnDestroy, input, output, model, effect, computed } from '@angular/core';
import { UserService } from '../../_shared/service/user.service';
import { Router, ActivatedRoute, Params, RouterLink } from '@angular/router';
import { LookupService } from '../../service/lookup.service';
import { EntryService } from '../../service/entry.service';
import { NgbModal, NgbDateAdapter, NgbAccordionDirective, NgbAccordionItem, NgbAccordionHeader, NgbAccordionToggle, NgbAccordionButton, NgbCollapse, NgbAccordionCollapse, NgbAccordionBody, NgbNav, NgbNavItem, NgbNavItemRole, NgbNavLink, NgbNavLinkBase, NgbNavContent, NgbNavOutlet } from '@ng-bootstrap/ng-bootstrap';
import { base, baseApi } from '../../_shared/constant.service';
import { NgbUnixTimestampAdapter } from '../../_shared/service/date-adapter';
import { PlatformLocation, NgTemplateOutlet, NgStyle, NgClass, DatePipe } from '@angular/common';
import { HttpClient, HttpEventType, HttpResponse } from '@angular/common/http';
import { ToastService } from '../../_shared/service/toast-service';
import { RunService } from '../../service/run.service';
import { LogService } from 'src/app/_shared/service/log.service';
import { ServerDate, btoaUTF, compileTpl, deepMerge, hashObject, loadScript, resizeImage } from 'src/app/_shared/utils';
import { first, map, share, tap, withLatestFrom } from 'rxjs/operators';
import { ViewChild } from '@angular/core';
import dayjs from 'dayjs';
import * as echarts from 'echarts';
import { Observable, lastValueFrom } from 'rxjs';
import { RxStompService } from 'src/app/_shared/service/rx-stomp.service';
import { ComponentCanDeactivate } from 'src/app/_shared/service/can-deactivate-guard.service';
import { NgForm, FormsModule } from '@angular/forms';
import { ScreenComponent } from '../screen/screen.component';
import { ListComponent } from '../list/list.component';
import { FieldEditComponent } from '../../_shared/component/field-edit/field-edit.component';
import { FieldViewComponent } from '../../_shared/component/field-view.component';
import { FaIconComponent } from '@fortawesome/angular-fontawesome';
import { FormViewComponent } from '../../_shared/component/form-view.component';
import { StepWizardComponent } from '../../_shared/component/step-wizard.component';
import { PageTitleComponent } from '../../_shared/component/page-title.component';
import { EditLookupEntryComponent } from 'src/app/_shared/modal/edit-lookup-entry/edit-lookup-entry.component';

@Component({
    selector: 'app-form',
    templateUrl: './form.component.html',
    styleUrls: ['./form.component.css'],
    providers: [{ provide: NgbDateAdapter, useClass: NgbUnixTimestampAdapter }],
    standalone: true,
    imports: [FormsModule, PageTitleComponent, StepWizardComponent, FormViewComponent, NgbAccordionDirective, NgbAccordionItem, 
      NgbAccordionHeader, NgbAccordionToggle, NgbAccordionButton, NgbCollapse, NgbAccordionCollapse, NgbAccordionBody, 
      NgTemplateOutlet, NgbNav, NgbNavItem, NgbNavItemRole, NgbNavLink, NgbNavLinkBase, RouterLink, NgbNavContent, NgbNavOutlet, 
      NgStyle, NgClass, FaIconComponent, FieldViewComponent, FieldEditComponent, ListComponent, ScreenComponent, DatePipe,
      EditLookupEntryComponent
    ]
})
export class FormComponent implements OnInit, OnDestroy, AfterViewChecked, ComponentCanDeactivate {

  user: any;
  app: any;
  appConst: any;
  form: any;
  lookupIds: any;
  baseApi: string = baseApi;
  base: string = base;
  baseUrl: string = '';
  // prevEntry: any;
  // prevForm: any;

  pageSize = 15;

  accessToken: string = "";

  entry: any = { currentStatus: 'drafted', data: {} };

  data: any = {}

  lookup = {};

  saving = false;
  submitting = false;

  lookupKey = {};

  lookups = {};
  appId = input<number>();
  // @Input() entryId: number;
  entryId = input<number>(); // PERLU CHECK
  // @Output() saved = new EventEmitter();
  saved = output<any>();
  // @Output() submitted = new EventEmitter();
  submitted = output<any>();
  // @Output() closed = new EventEmitter();
  closed = output<any>();
  entryParam: any;
  // @Input() action: string = '';
  action = input<string>();
  // _action:string='';
  // @Input() formId: number;
  formId = input<number>();
  // _formId:number;
  // @Input() asComp: boolean;
  asComp = input<boolean>();
  preurl: string = '';
  loading: boolean;
  // @Input() $param$: any = {};
  $param$ = model<any>({});
  // _param:any = {};
  // @Input() tab: number = 0;
  tab = input<number>(0);
  tabComputed = computed(()=>this.tab() || 0)

  isEmpty = inputObject => inputObject && Object.keys(inputObject).length === 0;

  constructor(private userService: UserService, public runService: RunService,
    private router: Router, private route: ActivatedRoute, private http: HttpClient,
    private lookupService: LookupService, private entryService: EntryService,
    private modalService: NgbModal,
    private toastService: ToastService,
    private cdr: ChangeDetectorRef,
    private logService: LogService,
    private location: PlatformLocation,
    private rxStompService: RxStompService) {
    location.onPopState(() => this.modalService.dismissAll(''));
    // effect(()=>{
    //   console.log("tab value", this.tab())
    // })
    // this.utilityService.testOnline$().subscribe(online=>this.offline = !online);
  }

  @ViewChild('entryForm', { static: false }) entryForm: NgForm;

  formInactive: boolean;

  defaultParam: string = "{'$prev$.$id':$.$id}";

  liveSubscription: any[] = [];
  // $live$ = {
  //   watch: (ch: any[], fn) => {
  //     ch.forEach(c => {
  //       this.liveSubscription.push(this.rxStompService.watch('/' + c)
  //         .pipe(map((msg:any) => msg.body))
  //         .subscribe(fn));
  //     })
  //   },
  //   publish: (ch: any[], msg) => {
  //     ch.forEach(c => {
  //       this.rxStompService.publish({
  //         destination: '/' + c,
  //         body: msg,
  //         skipContentLengthHeader: true
  //       })
  //     })
  //   }
  // }

  ngOnInit() {

    this.app = this.runService.app;

    // new add
    // this._param = deepMerge(this._param,this.$param$());

    this.appConst = this.runService?.appConfig;

    this.accessToken = this.userService.getToken();
    this.userService.getUser().subscribe(user => {
      this.user = user;
      this.entry['email'] = user.email;

      // APP ID
      if (this.appId()){
        this.preurl = `/run/${this.appId()}`;
      }
      this.baseUrl = (location.protocol + '//' + location.hostname + (location.port ? ':' + location.port : '')) + '/#' + this.preurl;


      // this.route.parent.params
      //   .subscribe((params: Params) => {
      //     this.appId = params['appId'];
      //     if (this.appId) {
      //       this.preurl = `/run/${this.appId}`;
      //     }
      //     this.baseUrl = (location.protocol + '//' + location.hostname + (location.port ? ':' + location.port : '')) + '/#' + this.preurl;
      //     // console.log('HHH:::'+this.baseUrl);
      //   });


      // this.route.queryParams.subscribe(queryParams=>{
        
      // })


      // parameter entryId perlu ada utk execute form query n update page. maybe bleh pake 'single'
      // if (this.asComp()) {
      //   this.getForm(this.formId(), this.entryId(), this.action());
      // } else {
        this.route.queryParams.subscribe(queryParams => {
          console.log("param tab", this.tab())
          this.$param$.set(queryParams);
          if (this.entryId()) {
            this.entryParam = null;
          } else {
            this.entryParam = queryParams;
          }
          this.getForm(this.formId(), this.entryId(), this.action());
        })
      // }
      this.getLookupIdList(this.formId());


    });
  }

  dsChanged(ev, fieldCode) {
    this.$this$[fieldCode] = ev;
    this.fieldChange(ev, this.entry?.data, this.form.items[fieldCode], false)
  }

  ngAfterViewChecked() {
    this.cdr.detectChanges();
  }

  // activeTab=0;
  // getForm(formId, entryId, prevEntryId) {
  watchList = new Map();
  watchListSection: any = {};
  userUnauthorized: boolean;

  onInit;
  onSave;
  onSubmit;
  onView;

  sectionMap: any = {};
  // tabMap:any = {}
  getForm(formId, entryId, action) {
    // console.log("formId-form:"+formId);
    this.loading = true;
    this.userUnauthorized = false;
    this.runService.getForm(formId)
      .subscribe(form => {
        if (this.formId() == form.id) {
          this.form = form;
          this.form.activeNav = 0;
          var formTab = this.form.nav != 'simple' ? this.form.tabs : [{}]
          formTab.forEach(tab => {
            this.sectionMap[tab?.id] = this.filterSection(this.form.sections, ['section', 'list'], tab?.id)
          });

          // check interception
          // dlm accessList = [100,101,102]
          // dlm keys(user.groups) = ["100","101","102"]
          let intercept = this.form.accessList?.filter(v => Object.keys(this.user.groups).includes(v + ""));
          if (this.form.accessList && this.form.accessList?.length > 0 && intercept.length == 0 && !this.appId) {
            this.userUnauthorized = true;
          }

          // if (this.form.access && !this.user.groups[this.form.access.id] && !this.appId) {
          //   this.userUnauthorized = true;
          // }

          // delete this.entry;
          this.entry = { currentStatus: 'drafted', data: {} }; // reset entry 
          // console.log(this.entry);
          // console.log("-----\n\n");
          this.onInit = () => this.initForm(form.f, this.entry.data, form);
          this.onView = () => this.initForm(form.onView, this.entry.data, form);
          this.onSave = () => this.initForm(form.onSave, this.entry.data, form);
          this.onSubmit = () => this.initForm(form.onSubmit, this.entry.data, form);

          if (action == 'edit' && (entryId || !this.isEmpty(this.entryParam || {}))) {
            this.getData(entryId, form);
          } else if (action == 'edit-single') {
            this.getDataSingle(form);
            this.formInactive = (form.startDate && form.startDate > Date.now()) || (form.endDate && form.endDate < Date.now())
          } else if (action == 'prev') {
            this.formInactive = (form.startDate && form.startDate > Date.now()) || (form.endDate && form.endDate < Date.now())
            this.getPrevData(entryId, this.entryParam, form.prev);
          } else if (action == 'add') {
            this.formInactive = (form.startDate && form.startDate > Date.now()) || (form.endDate && form.endDate < Date.now())
            this.initForm(this.form.f, this.entry.data, this.form);
          } else {
            this.getData(entryId, form);
            // this.initForm(this.form.f); //comment after change initform receive data parameter
          }
          this.loading = false;

          // this.watchList = new Map();
          // make sure order of eval field is followed
          this.form.sections.forEach(s => {
            if (['section'].indexOf(s.type) > -1) { // watch for section eval. previously section+approval
              s.items.forEach(item => {
                if (this.form.items[item.code].type == 'eval') {
                  this.watchList.set(item.code, this.form.items[item.code].f)
                }
              });
            } else if (s.type == 'list') { // watch for section in list
              this.watchListSection[s.code] = new Map();
              s.items.forEach(item => {
                if (this.form.items[item.code].type == 'eval') {
                  this.watchListSection[s.code].set(item.code, this.form.items[item.code].f)
                }
              });
            }
          })
          
          this.evalAll(this.entry.data);
          this.filterTabs();


          // JIKA EDIT FORM YG ADA PREV
          // if (form.prev) {

          //   // this.formService.getForm(form.prev)
          //   //   .subscribe(prevForm => {
          //       // this.prevForm = prevForm;
          //       if (entryId) {
          //         this.getPrevData(entryId, form.prev.id);
          //       }
          //     // });
          // }

        }

      });
  }


  // getAllLookup() {
  //   var items = this.form.items.filter(c => { c.dataSource != null });
  //   for (var i in items) {
  //     if (!items.hasOwnProperty(i)) {

  //     }
  //   }
  // }

  getLookupIdList(id) {
    this.lookupService.getInForm(id, ['section', 'list'])
      .subscribe(res => {
        this.lookupIds = res;
        this.lookupIds.forEach(key => {
          this.lookupKey[key.code] = {
            ds: key.dataSource,
            type: key.type
          }
          // var param = null;
          // try {
          // param = this._eval(this.entry.data, key.dataSourceInit);// new Function('$', '$prev$', '$user$', '$lookup$', '$http$', 'return ' + key.dataSourceInit)(this.entry, this.entry && this.entry.prev, this.user, this.getLookup, this.httpGet)
          // } catch (e) { }

          // only pre-load lookup data if not select or text. select/text init param value might not available for loading
          // select/text also loaded when onfocus.
          if (['select', 'text'].indexOf(res.type) == -1) {
            this.getLookup(key.code, key.dataSourceInit, this.entry.data);
          }
        });
      });
  }

  lookupLoading: any = {}

  lookupDataObs: any = {}

  _getLookup = (code, param, cb?, err?) => {
    if (code) {
      this.lookupLoading[code] = true;
      this._getLookupObs(code, param, cb, err)
        .subscribe({
          next: res => {
            this.lookup[code] = res;
            this.lookupLoading[code] = false;
          }, error: err => {
            this.lookupLoading[code] = false;
          }
        })
    }
  }

  _getLookupObs(code, param, cb?, err?): Observable<any> {

    var cacheId = 'key_' + btoaUTF(this.lookupKey[code].ds + hashObject(param ?? {}));
    // masalah nya loading ialah async... so, mun simultaneous load, cache blom diset
    // bleh consider cache observable instead of result.
    // tp bila pake observable.. request dipolah on subscribe();
    // settle with share()
    if (this.lookupDataObs[cacheId]) {
      return this.lookupDataObs[cacheId]
    }
    // start loading
    // console.log('loading '+this.lookupKey[code],code);
    if (this.lookupKey[code].type == 'modelPicker') {
      param = Object.assign(param || {}, { email: this.user.email });
      this.lookupDataObs[cacheId] = this.entryService.getListByDatasetData(this.lookupKey[code].ds, param ? param : null)
        .pipe(
          tap({ next: cb, error: err }), first(), share()
        )
    } else {
      // param = Object.assign(param || {}, { sort: 'id,asc' });
      param = Object.assign(param || {}, {});
      this.lookupDataObs[cacheId] = this.lookupService.getByKey(this.lookupKey[code].ds, param ? param : null)
        .pipe(
          tap({ next: cb, error: err }), first(),
          map((res:any) => res.content), share()
        )
    }
    return this.lookupDataObs[cacheId];
  }

  getLookup = (code, dsInit: string, dataV?: any) => {
    if (this.lookupKey[code]?.ds) {
      if (!dataV) {
        dataV = this.entry.data;
      }
      var param = null;
      try {
        param = this._eval(dataV, dsInit, this.form);// new Function('$', '$prev$', '$user$', '$lookup$', '$http$', 'return ' + key.dataSourceInit)(this.entry, this.entry && this.entry.prev, this.user, this.getLookup, this.httpGet)
      } catch (e) { this.logService.log(`{form-lookup-${code}-dsInit}-${e}`) }
      this._getLookup(code, param);
    }
  }

  getLookupSearch = (event, code, dsInit: string, dataV?: any) => {
    if (dsInit && dsInit.indexOf('$search$') > -1) {
      dsInit = dsInit.replace('$search$', event.term);
      this.getLookup(code, dsInit, dataV);
    }
  }


  httpGet = this.runService.httpGet;
  httpPost = this.runService.httpPost;
  endpointGet = (code, params, callback, error) => this.runService.endpointGet(code, this.form.appId, params, callback, error)

  // httpGet = (url, callback, error) => {
  //   let header = (url.indexOf(base) == -1) ? { 'clear': 'true' } : undefined;
  //   return lastValueFrom(this.http.get(url, { headers: header })
  //     .pipe(
  //       tap({ next: callback, error: error }), first()
  //     ))
  // }

  // httpPost = (url, body, callback, error) => {
  //   let header = (url.indexOf(base) == -1) ? { 'clear': 'true' } : undefined;
  //   return lastValueFrom(this.http.post(url, body, { headers: header })
  //     .pipe(
  //       tap({ next: callback, error: error }), first()
  //     ));
  // }

  // endpointGet = (code, params, callback, error) => {
  //   return lastValueFrom(this.http.get(this.baseApi + `/endpoint/run/${this.form.appId}/${code}`, { params: params })
  //     .pipe(
  //       tap({ next: callback, error: error }), first()
  //     ));
  // }

  navIndex:number=0;
  @ViewChild('nav') navOutlet;
  setActive = (index) => {
    this.navIndex = index;
    if (['tabs', 'pills'].indexOf(this.form.nav) > -1) {
      this.navOutlet.select(this.action() + index);
    } else if (this.form.nav == 'accordions') {
      this.navOutlet.toggle(this.action() + index);
    }
  }

  filteredTabs = [];
  filterTabs() {
    this.filteredTabs = this.form.tabs.filter(t => this.preCheck(t));
  }

  // $el='as';
  fieldChange($event, data, field, section) {
    // console.log("k")
    // console.log($event);
    if (field.post) {
      try {
        this._eval(data, field.post, this.form);
      } catch (e) { this.logService.log(`{form-${field.code}-post}-${e}`) }
    }
    if (!section) {
      this.evalAll(data);
    } else {
      this.evalAllSection(data, section);
      this.evalAll(this.entry.data)
    }

    this.filterTabs();
    // eval scoped to entrydata or child
    // if (evalEntryData) {
    //   this.evalAll(this.entry.data);
    // }
    // else{
    //   this.evalAll(data)
    // }
    // need to evalAll for entry.data
  }

  submit = (resubmit: boolean) => {
    this.saving = true;
    this._save(this.form)
      .subscribe({
        next: res => {
          this.entry = res;
          this.saving = false;
          this.submitting = true;
          this.entryService.submit(res.id, this.user.email, resubmit)
            .subscribe({
              next: res => {
                if (this.form.onSubmit) {
                  try {
                    this._eval(this.entry.data, this.form.onSubmit, this.form);
                  } catch (e) { this.logService.log(`{form-${this.form.title}-onSubmit}-${e}`) }
                }
                this.toastService.show("Entry submitted successfully", { classname: 'bg-success text-light' });
                this.submitting = false;
                if (this.asComp()) {
                  this.submitted.emit(res);
                } else {
                  if (!(this.form.x && this.form.x.submitAndStay)) {
                    this.router.navigate([this.preurl, "form", this.form.id, "view"], { queryParams: { entryId: res.id } });
                  }
                }
              }, error: err => {
                this.submitting = false;
                this.toastService.show("Entry submission failed", { classname: 'bg-danger text-light' });
              }
            })
        }, error: err => {
          this.saving = false;
          this.toastService.show("Entry saving failed", { classname: 'bg-danger text-light' });
        }
      })
  }


  getDataSingle(form) {
    // console.log(form);
    this.entryService.getFirstEntryByParam(this._eval({}, form.singleQ, form), form.id)
      .subscribe({
        next: res => {
          this.entry = res; //Object.assign(this.entry, res);
          this.evalAll(this.entry.data);
          this.initForm(form.f, this.entry.data, form);
          this.loading = false;
        }, error: err => {
          // consider getPrevData() but need to add support for prevParam;
          if (form.prev) {
            this.getPrevData(null, this.getPrevParam(this._eval({}, form.singleQ, form)), form.prev);
          } else {
            this.initForm(form.f, this.entry.data, form);
            this.loading = false;
          }
        }
      })
  }

  getPrevParam = (p: any) => {
    let obj = {};
    Object.keys(p).forEach(k => {
      if (k.includes('$prev$.')) {
        obj[k.replace('$prev$.', '$.')] = p[k];
      }
    })
    return obj;
  };

  filterSection = (sectionList, type, tab) => sectionList && sectionList.filter(s => type.indexOf(s.type) > -1 && (!tab || s.parent == tab));

  filesMap: any = {}
  getDataFiles(holder, id) {
    if (id) {
      this.filesMap[holder] = {};
      this.entryService.getEntryFiles(id)
        .subscribe(res => {
          res.content?.forEach(ea => this.filesMap[holder][ea.fileUrl] = ea);
        })
    }
  }
  getData(id, form) {
    // console.log(this.entry);
    if (id) {
      // if using entry id
      this.loading = true;
      this.entryService.getEntry(this.entryId(), form.id)
        .subscribe({
          next: res => {
            this.entry = res;//Object.assign(this.entry, res);
            this.getDataFiles('data', res.id);
            this.evalAll(this.entry.data);
            this.initForm(this.form.f, this.entry.data, this.form);
            this.loading = false;
            if (form.prev){
              // this.prevEntry = res.prev;
              // this.entry.prev = res.data;
              // this.getDataFiles('prev', res.id);
              // this.evalAll(this.entry.data);
              // this.initForm(form?.onView, res.data, form);
              // this.initForm(this.form.f, this.entry.data, this.form);
              // this.loading = false;
              this.getPrevData(res.prev?.$id, {}, form.prev);
            }
          }, error: err => {
            this.loading = false;
          }
        })
    } else {
      if (!this.isEmpty(this.entryParam)) {
        // if using param instead of entry id
        this.loading = true;
        this.entryService.getFirstEntryByParam(this.entryParam, form.id)
          .subscribe({
            next: res => {
              this.entry = res;//Object.assign(this.entry, res);
              this.getDataFiles('data', res.id);
              this.evalAll(this.entry.data);
              this.initForm(this.form.f, this.entry.data, this.form);
              this.loading = false;
            }, error: err => {
              this.loading = false;
            }
          })
      } else {
        if (this.form.single) {
          var f = this._eval({}, this.form.singleQ, this.form);
          this.entryService.getFirstEntryByParam(f, form.id)
            .subscribe({
              next: res => {
                this.entry = res; //Object.assign(this.entry, res);
                this.getDataFiles('data', res.id);
                this.evalAll(this.entry.data);
                this.initForm(this.form.f, this.entry.data, this.form);
                this.loading = false;
              }, error: err => {
                this.loading = false;
              }
            })
        }
      }

    }
  }


  prevId: number | null;
  prevEntry:any;
  prevLoading:boolean;
  getPrevData(id, params, form) {
    // console.log(form);
    if (id) {
      this.prevId = id;
      this.prevLoading = true;
      this.entryService.getEntry(id, form?.id)
        .subscribe({
          next: res => {
            this.prevEntry = res;
            this.entry.prev = res.data;
            this.getDataFiles('prev', res.id);
            this.evalAll(this.entry.data);
            this.initForm(form?.onView, res.data, form);
            this.initForm(this.form.f, this.entry.data, this.form);
            this.prevLoading = false;
          }, error: err => {
            this.prevLoading = false;
          }
        })
    } else {
      // alert(form.title);
      // console.log("predData-byparam:"+this.entryParam)
      this.prevLoading = true;
      this.entryService.getFirstEntryByParam(params, form?.id)
        .subscribe({
          next: res => {
            this.prevId = res.id;
            this.prevEntry = res;
            this.entry.prev = res.data;
            this.getDataFiles('prev', res.id);
            this.evalAll(this.entry.data);
            this.initForm(form?.onView, res.data, form);
            this.initForm(this.form.f, this.entry.data, this.form);
            this.prevLoading = false;
          }, error: err => {
            this.prevLoading = false;
          }
        });
    }
  }

  progBack(index) {
    this.saving = true;
    this._save(this.form)
      .subscribe({
        next: res => {
          this.saving = false;
          this.setActive(index - 1);
        },
        error: err => { 
          this.saving = false;
        }
      })
  }

  progNext(index) {
    this.saving = true;
    this._save(this.form)
      .subscribe({
        next: res => {
          this.saving = false;
          this.setActive(index + 1);
        },
        error: err => {
          this.saving = false;
        }
      })
  }

  save = () => {
    this.saving = true;
    // console.log(this.entry);
    this._save(this.form)
      .subscribe({
        next: res => {
          this.entry = res;
          this.saving = false;
          if (this.form.onSave) {
            try {
              this._eval(this.entry.data, this.form.onSave, this.form);
            } catch (e) { this.logService.log(`{form-${this.form.title}-onSave}-${e}`) }
          }
          // this.router.navigate(["run", this.form.app.id, "form", this.form.id, "view", this.entry.id]);
          this.toastService.show("Entry saved successfully", { classname: 'bg-success text-light' });
          if (this.asComp()) {
            this.saved.emit(res);
          } else {
            if (!(this.form.x && this.form.x.saveAndStay)) {
              this.router.navigate([this.preurl, "form", this.form.id, "view"], { queryParams: { entryId: this.entry.id } });
            }
          }
        }, error: err => {
          this.saving = false;
          this.toastService.show("Entry saving failed", { classname: 'bg-danger text-light' });
        }
      })
  }

  _save = (form) => {
    // this.evalAll(this.entry.data);
    let userKey = this.user.email;
    if (form?.x?.userKey) {
      userKey = compileTpl(form?.x?.userKey, { $user$: this.user, $: this.entry?.data, $_: this.entry, $prev$: this.entry?.prev, $base$: this.base, $baseUrl$: this.baseUrl, $baseApi$: this.baseApi, $this$: this.$this$, $param$: this.$param$(), $ngForm$: this.entryForm })
    }
    return this.entryService.save(form.id, this.entry, this.prevId, userKey)
      .pipe(
        tap({
          next: (e) => {
            this.entry = e;
            this.linkFiles(e);
            // this.$digest$(); // this prevent ask navigate to be displayed!! NOT-WORKING. Actual reason for dirty is html keep-value
            this.entryForm.form.markAsPristine();
            // console.log("onsave", this.entryForm.form.pristine);
          }
        }), first()
      )
  }

  linkFiles(e) {
    this.entryService.linkFiles(e.id, this.entryFiles, this.user.email)
      .subscribe(res => { });
  }

  file: any = {}

  preCheck(f, dataV?: any, prop?:string) {
    let res = undefined;
    try {
      if (!dataV) {
        dataV = this.entry.data;
      }
      if (!prop){
        prop = 'pre';
      }
      res = this._pre(dataV, f?.[prop]);//new Function('$', '$prev$', '$user$', 'return ' + f.pre)(this.entry.data, this.entry && this.entry.prev, this.user);
    } catch (e) { this.logService.log(`{form-${f?.code}-precheck}-${e}`) }
    return !f?.[prop] || res;
  }

  evalAll(data) {
    this.watchList.forEach((value, key) => {
      data[key] = this.changeEval(data, value);
    })
  }
  evalAllSection(data, section) {
    this.watchListSection[section.code]?.forEach((value, key) => {
      data[key] = this.changeEval(data, value);
    })
  }

  changeEval(data, js) {
    let res = undefined;
    try {
      res = this._eval(data, js, this.form);// new Function('$', '$prev$', '$user$', '$http$', 'return ' + f.f)(data, this.entry && this.entry.prev, this.user, this.httpGet);
    } catch (e) { this.logService.log(`{form-${this.form.title}-change}-${e}`) }
    return res;
  }

  $digest$ = () => {
    this.cdr.detectChanges()
  }

  // added data parameter because form with prev data, prev view initform will evaluate this.entry.data instead of with previous data
  initForm(js, data, form) {
    let res = undefined;
    try {
      res = this._eval(data, js, form);// new Function('$', '$prev$', '$user$', '$http$', 'return ' + f)(this.entry.data, this.entry && this.entry.prev, this.user, this.httpGet);
      this.filterTabs();
    } catch (e) { this.logService.log(`{form-${this.form.title}-initForm}-${e}`) }
    return res;
  }

  loadScript = loadScript;

  log = (log) => this.logService.log(JSON.stringify(log));

  $toast$ = (content, opt) => this.toastService.show(content, opt);

  elMap: any = {}
  $q = (el) => {
    if (!this.elMap[el]) {
      this.elMap[el] = document.querySelector(el);
    }
    return this.elMap[el];
  }

  $this$ = {};
  _eval = (data, v, form) => new Function('$_', '$', '$prev$', '$user$', '$conf$', '$action$', '$lookup$', '$http$', '$post$', '$endpoint$', '$saveAndView$', '$save$', '$submit$', '$el$', '$form$', '$this$', '$loadjs$', '$digest$', '$param$', '$log$', '$activate$', '$activeIndex$', '$toast$', '$update$', '$updateLookup$', '$base$', '$baseUrl$', '$baseApi$', '$ngForm$', '$lookupList$', 'dayjs', 'ServerDate', 'echarts', '$live$', '$token$', '$merge$','$web$', '$file$', 'onInit', 'onSave', 'onSubmit', 'onView', '$q$',
    `return ${v}`)(this.entry, data, this.entry && this.entry.prev, this.user, this.runService?.appConfig, this.action(), this._getLookup, this.httpGet, this.httpPost, this.endpointGet, this.save, ()=>this._save(form||this.form), this.submit, form?.items||this.form?.items, form||this.form, this.$this$, this.loadScript, this.$digest$, this.$param$(), this.log, this.setActive, this.navIndex, this.$toast$, this.updateField, this.updateLookup, this.base, this.baseUrl, this.baseApi, this.entryForm, this.lookup, dayjs, ServerDate, echarts, this.runService?.$live$(this.liveSubscription), this.accessToken, deepMerge, this.http, this.filesMap, this.onInit, this.onSave, this.onSubmit, this.onView, this.$q);
  _pre = (data, v) => new Function('$_', '$', '$prev$', '$user$', '$conf$', '$action$', '$el$', '$form$', '$this$', '$digest$', '$param$', '$log$', '$base$', '$baseUrl$', '$baseApi$', '$ngForm$', '$lookupList$', 'dayjs', 'ServerDate', '$token$', '$file$', '$activeIndex$',
    `return ${v}`)(this.entry, data, this.entry && this.entry.prev, this.user, this.runService?.appConfig, this.action(), this.form && this.form.items, this.form, this.$this$, this.$digest$, this.$param$(), this.log, this.base, this.baseUrl, this.baseApi, this.entryForm, this.lookup, dayjs, ServerDate, this.accessToken, this.filesMap, this.navIndex);

  /** Need to study either to implement deepMerge when updated entry: refer view-component */
  updateField = (entryId, value, callback, error) => {
    return lastValueFrom(this.entryService.updateField(entryId, value, this.form.appId)
      .pipe(
        tap({ next: callback, error: error }), first()
      ));
  }

  updateLookup = (entryId, value, callback, error) => {
    return lastValueFrom(this.entryService.updateLookup(entryId, value, this.form.appId)
      .pipe(
        tap({ next: callback, error: error }), first()
      ));
  }

  editChildData: any;
  editChildItems: any
  editChild(content, section, data, isNew) {
    this.editChildData = data;
    this.editChildItems = { section: section }
    history.pushState(null, null, window.location.href);
    this.modalService.open(content, { backdrop: 'static' })
      .result.then(res => {
        /** Ada evaluated field main masok dlm child sebab evalAll(data) kt fieldChange */
        if (res) {
          Object.assign(data, res);
        }
        if (isNew) {
          if (!this.entry.data[section.code]) {
            this.entry.data[section.code] = []
          }
          res['$index'] = this.entry.data[section.code].length;
          this.entry.data[section.code].push(res);
        }
        this.entryForm.form.markAsDirty();
        this.evalAll(this.entry.data);
      }, err => { });
  }

  removeChild(section, $index) {
    if (section.confirmable) {
      if (confirm("Are you sure you want to remove this data?")) {
        this.entry.data[section.code].splice($index, 1);
        this.entryForm.form.markAsDirty();
      }
    } else {
      this.entry.data[section.code].splice($index, 1);
      this.entryForm.form.markAsDirty();
    }

    this.evalAll(this.entry.data);
  }

  // uploading = {};

  onFileClear($event, data, f, evalEntryData) {
    // console.log("FIle SELECT:" + $event);
    /** Problem, bila user click Cancel, akan remove suma dlm entryFIles
     * sbb $event return current file value;
     * FIXED: Handle sebelah field-edit. If file length == 0, then dont trigger clear
     */
    // if ($event!=data[f.code]) {

    var fileList = f.subType.indexOf('multi') > -1 ? $event : [$event];
    this.entryService.deleteAttachment($event)
      .subscribe(res => {
        // data[f.code]=null;
        delete this.uploadProgress[f.code];
        this.fieldChange($event, data, f, evalEntryData);
        fileList.forEach(file => {
          this.entryFiles.splice(this.entryFiles.indexOf(file), 1);
          delete this.filesMap[file];
          // console.log("###Cleared:"+file+", index#:"+this.entryFiles.indexOf(file));
        })
        // console.log("##FILE CLEARED##")
      });
    // }
  }

  entryFiles: any[] = [];

  uploadProgress: any = {}

  onUpload(fileList, data, f, evalEntryData, index) {
    // console.log(fileList, data, f, evalEntryData);
    // [file]
    // console.log("is upload"); 
    if (fileList && fileList.length) {
      var totalSize = fileList.reduce((total, i) => total + i.size, 0);
      var progressSize = 0;
      if (['image', 'imagemulti'].indexOf(f.subType) > -1) {

        // optimize image file here (ie: resize, compress)
        // files = compressImage(files, 300, 300)
        // const resizedImage = await resizeImage(config)
        if (f.subType == 'imagemulti') {
          var list = [];
          for (var i = 0; i < fileList.length; i++) {
            let file = fileList[i];
            resizeImage({
              file: file,
              maxSize: f.v.max
            }).then(resizedImage => {
              // console.log("FILENAME### : " + file.name)
              this.entryService.uploadAttachment(resizedImage, f.id, f.x?.bucket, this.form.appId, file.name)
                .subscribe({
                  next: res => {
                    if (res.type === HttpEventType.UploadProgress) {
                      progressSize += res.loaded;
                      this.uploadProgress[f.code + (index ?? '')] = Math.round(100 * progressSize / totalSize);
                    } else if (res instanceof HttpResponse) {
                      list.push(res.body.fileUrl);
                      data[f.code] = list;
                      this.filesMap[res.body.fileUrl] = res.body;
                      this.fieldChange(fileList, data, f, evalEntryData);
                      this.entryFiles.push(res.body.fileUrl);

                      // EXTRACT BY AI
                      if (f.x?.extractor){
                        this.extractData(f,f.x?.extractor,[res.body.fileUrl], data);
                      }
                    }
                  }, error: err => {
                    this.toastService.show("File upload failed: " + err.error?.message, { classname: 'bg-danger text-light' });
                    console.error(err);
                  }
                })
            }).catch(function (err) {
              console.error(err);
            });
          }
        } else {
          resizeImage({
            file: fileList[0],
            maxSize: f.v.max
          }).then(resizedImage => {
            this.entryService.uploadAttachment(resizedImage, f.id, f.x?.bucket, this.form.appId, fileList[0].name)
              .subscribe({
                next: res => {
                  if (res.type === HttpEventType.UploadProgress) {
                    progressSize += res.loaded;
                    this.uploadProgress[f.code + (index ?? '')] = Math.round(100 * progressSize / totalSize);
                  } else if (res instanceof HttpResponse) {
                    data[f.code] = res.body.fileUrl;
                    this.filesMap[res.body.fileUrl] = res.body;
                    this.fieldChange(fileList, data, f, evalEntryData);
                    this.entryFiles.push(res.body.fileUrl);

                    // EXTRACT BY AI
                    if (f.x?.extractor){
                      this.extractData(f,f.x?.extractor,[res.body.fileUrl], data);
                    }
                  }
                }, error: err => {
                  this.toastService.show("File upload failed: " + err.error?.message, { classname: 'bg-danger text-light' });
                }
              })
          }).catch(function (err) {
            console.error(err);
          });
        }

      } else {
        if (f.subType == 'othermulti') {
          var list = [];
          // this.fileLarge[f.id]=[];
          for (var i = 0; i < fileList.length; i++) {
            var file = fileList[i];
            if (f.v.max && file.size > f.v.max * 1024 * 1024) {
              return;
            }
            this.entryService.uploadAttachment(file, f.id, f.x?.bucket, this.form.appId, file.name)
            .subscribe({
              next:res=>{
                if (res.type === HttpEventType.UploadProgress) {
                  progressSize += res.loaded;
                  this.uploadProgress[f.code + (index ?? '')] = Math.round(100 * progressSize / totalSize);
                } else if (res instanceof HttpResponse) {
                  list.push(res.body.fileUrl);
                  data[f.code] = list;
                  this.filesMap[res.body.fileUrl] = res.body;
                  this.fieldChange(fileList, data, f, evalEntryData);
                  this.entryFiles.push(res.body.fileUrl);
                  
                  // EXTRACT FOR AI
                  if (f.x?.extractor){
                    this.extractData(f,f.x?.extractor,[res.body.fileUrl], data);
                  }
                }
              },
              error: err=>{
                this.toastService.show("File upload failed: " + err.error?.message, { classname: 'bg-danger text-light' });
              }
            })
          }
        } else {
          var file = fileList[0];
          // this.fileLarge[f.id]=[]
          if (f.v.max && file.size > f.v.max * 1024 * 1024) {
            return;
          }
          this.entryService.uploadAttachment(file, f.id, f.x?.bucket, this.form.appId, file.name)
          .subscribe({
            next:res=>{
              if (res.type === HttpEventType.UploadProgress) {
                progressSize += res.loaded;
                this.uploadProgress[f.code + (index ?? '')] = Math.round(100 * progressSize / totalSize);
              } else if (res instanceof HttpResponse) {
                data[f.code] = res.body.fileUrl;
                this.filesMap[res.body.fileUrl] = res.body;
                this.fieldChange(fileList, data, f, evalEntryData);
                this.entryFiles.push(res.body.fileUrl);

                if (f.x?.extractor){
                  this.extractData(f,f.x?.extractor,[res.body.fileUrl], data);
                }
              }
            },
            error: err=>{
              console.log(err)
              this.toastService.show("File upload failed: " + err.statusText, { classname: 'bg-danger text-light' });
            }
          })
        }
      }
    }
  }

  
  editLookupItem:any={};
  editLookupEntryData:any={};
  editLookupEntry(content,field,entryData,value){
    this.lookupService.getLookup(field.dataSource)
    .subscribe(lookup=>{
      this.editLookupItem = lookup;
      this.editLookupEntryData = value;
      history.pushState(null, null, window.location.href);
      this.modalService.open(content, { backdrop: 'static' })
      .result.then(data => {
        if (lookup.x?.codeHidden){
          data.code = data.name
        }
        this.lookupService.saveEntry(lookup.id, data)
        .subscribe({
          next: (res) => {
            this.getLookup(field.code, field.dataSourceInit, entryData);
            if (['select','radio','radioBtn'].indexOf(field.type)>-1){
              entryData[field.code] = res;    
            }                      
            if (['checkboxOption'].indexOf(field.type)>-1){
              if (!entryData[field.code]){
                entryData[field.code]=[];
              }
              entryData[field.code]?.push(res);    
            }                      
            this.toastService.show("Entry successfully saved", { classname: 'bg-success text-light' });
          }, error: (err) => {
            this.toastService.show("Entry saving failed", { classname: 'bg-danger text-light' });
          }
        })
      }, res => { })     
    })
  }

  extractData(field,cognaId, docList, data){
    this.lookupLoading[field.code] = true;
    this.runService.cognaExtract(cognaId,null,docList,false,this.user.email)
    .subscribe({
      next:res=>{
        this.lookupLoading[field.code] = false;
        var rval = res[0];
        delete rval[field.code];
        deepMerge(data, rval);
        this.evalAll(data);
      },
      error:err=>{
        this.lookupLoading[field.code] = false;
      }
    });
  }

  getIcon = (str) => str ? str.split(":") : ['far', 'file'];

  // reason nya xmok swap b4 tok sbb nya linked by reference, perlu pake Object.assign()
  reorder(items, index, op) {
    items[index + op].altClass = 'swapStart';
    items[index].altClass = 'swapStart';

    items.forEach((i, $index) => {
      i.sortOrder = $index;
    }); // ensure current sortorder using index, to prevent jumping ordering

    var temp = Object.assign({}, items[index + op]);
    var tempSortOrder = items[index + op].sortOrder;
    items[index + op].sortOrder = items[index].sortOrder;
    items[index + op] = Object.assign({}, items[index]); // consider deepMerge

    items[index].sortOrder = tempSortOrder;
    items[index] = temp;
    // this.swapPositions(items,index,index+op);
    setTimeout(() => {
      items[index + op].altClass = 'swapEnd';
      items[index].altClass = 'swapEnd';
    }, 500);
  }

  canDeactivate() {
    return !(this.form?.x?.askNavigate && this.entryForm?.dirty); //asknavigate && dirty --> modal
  }

  ngOnDestroy() {
    this.liveSubscription.forEach(sub => sub.unsubscribe());
  }
}